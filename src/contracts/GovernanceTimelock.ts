/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from 'ethers';
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from '@ethersproject/abi';
import type { Listener, Provider } from '@ethersproject/providers';
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from './common';

export interface GovernanceTimelockInterface extends utils.Interface {
  functions: {
    'CANCELLOR_ROLE()': FunctionFragment;
    'DEFAULT_ADMIN_ROLE()': FunctionFragment;
    'EXECUTOR_ROLE()': FunctionFragment;
    'PROPOSER_ROLE()': FunctionFragment;
    'SUPREMECOURT_ROLE()': FunctionFragment;
    'TIMELOCK_ADMIN_ROLE()': FunctionFragment;
    'VETO_ROLE()': FunctionFragment;
    '_disputed(bytes32)': FunctionFragment;
    'callDispute(bytes32)': FunctionFragment;
    'callDisputeResolve(bytes32,bool,bytes)': FunctionFragment;
    'cancel(bytes32)': FunctionFragment;
    'execute(address,uint256,bytes,bytes32,bytes32)': FunctionFragment;
    'executeBatch(address[],uint256[],bytes[],bytes32,bytes32)': FunctionFragment;
    'getDisputeStatus(bytes32)': FunctionFragment;
    'getMinDelay()': FunctionFragment;
    'getRoleAdmin(bytes32)': FunctionFragment;
    'getTimestamp(bytes32)': FunctionFragment;
    'grantRole(bytes32,address)': FunctionFragment;
    'hasRole(bytes32,address)': FunctionFragment;
    'hashOperation(address,uint256,bytes,bytes32,bytes32)': FunctionFragment;
    'hashOperationBatch(address[],uint256[],bytes[],bytes32,bytes32)': FunctionFragment;
    'isOperation(bytes32)': FunctionFragment;
    'isOperationDone(bytes32)': FunctionFragment;
    'isOperationPending(bytes32)': FunctionFragment;
    'isOperationReady(bytes32)': FunctionFragment;
    'renounceRole(bytes32,address)': FunctionFragment;
    'revokeRole(bytes32,address)': FunctionFragment;
    'schedule(address,uint256,bytes,bytes32,bytes32,uint256)': FunctionFragment;
    'scheduleBatch(address[],uint256[],bytes[],bytes32,bytes32,uint256)': FunctionFragment;
    'supportsInterface(bytes4)': FunctionFragment;
    'updateDelay(uint256)': FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | 'CANCELLOR_ROLE'
      | 'DEFAULT_ADMIN_ROLE'
      | 'EXECUTOR_ROLE'
      | 'PROPOSER_ROLE'
      | 'SUPREMECOURT_ROLE'
      | 'TIMELOCK_ADMIN_ROLE'
      | 'VETO_ROLE'
      | '_disputed'
      | 'callDispute'
      | 'callDisputeResolve'
      | 'cancel'
      | 'execute'
      | 'executeBatch'
      | 'getDisputeStatus'
      | 'getMinDelay'
      | 'getRoleAdmin'
      | 'getTimestamp'
      | 'grantRole'
      | 'hasRole'
      | 'hashOperation'
      | 'hashOperationBatch'
      | 'isOperation'
      | 'isOperationDone'
      | 'isOperationPending'
      | 'isOperationReady'
      | 'renounceRole'
      | 'revokeRole'
      | 'schedule'
      | 'scheduleBatch'
      | 'supportsInterface'
      | 'updateDelay',
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: 'CANCELLOR_ROLE',
    values?: undefined,
  ): string;
  encodeFunctionData(
    functionFragment: 'DEFAULT_ADMIN_ROLE',
    values?: undefined,
  ): string;
  encodeFunctionData(
    functionFragment: 'EXECUTOR_ROLE',
    values?: undefined,
  ): string;
  encodeFunctionData(
    functionFragment: 'PROPOSER_ROLE',
    values?: undefined,
  ): string;
  encodeFunctionData(
    functionFragment: 'SUPREMECOURT_ROLE',
    values?: undefined,
  ): string;
  encodeFunctionData(
    functionFragment: 'TIMELOCK_ADMIN_ROLE',
    values?: undefined,
  ): string;
  encodeFunctionData(functionFragment: 'VETO_ROLE', values?: undefined): string;
  encodeFunctionData(
    functionFragment: '_disputed',
    values: [PromiseOrValue<BytesLike>],
  ): string;
  encodeFunctionData(
    functionFragment: 'callDispute',
    values: [PromiseOrValue<BytesLike>],
  ): string;
  encodeFunctionData(
    functionFragment: 'callDisputeResolve',
    values: [
      PromiseOrValue<BytesLike>,
      PromiseOrValue<boolean>,
      PromiseOrValue<BytesLike>,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'cancel',
    values: [PromiseOrValue<BytesLike>],
  ): string;
  encodeFunctionData(
    functionFragment: 'execute',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'executeBatch',
    values: [
      PromiseOrValue<string>[],
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BytesLike>[],
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'getDisputeStatus',
    values: [PromiseOrValue<BytesLike>],
  ): string;
  encodeFunctionData(
    functionFragment: 'getMinDelay',
    values?: undefined,
  ): string;
  encodeFunctionData(
    functionFragment: 'getRoleAdmin',
    values: [PromiseOrValue<BytesLike>],
  ): string;
  encodeFunctionData(
    functionFragment: 'getTimestamp',
    values: [PromiseOrValue<BytesLike>],
  ): string;
  encodeFunctionData(
    functionFragment: 'grantRole',
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(
    functionFragment: 'hasRole',
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(
    functionFragment: 'hashOperation',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'hashOperationBatch',
    values: [
      PromiseOrValue<string>[],
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BytesLike>[],
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'isOperation',
    values: [PromiseOrValue<BytesLike>],
  ): string;
  encodeFunctionData(
    functionFragment: 'isOperationDone',
    values: [PromiseOrValue<BytesLike>],
  ): string;
  encodeFunctionData(
    functionFragment: 'isOperationPending',
    values: [PromiseOrValue<BytesLike>],
  ): string;
  encodeFunctionData(
    functionFragment: 'isOperationReady',
    values: [PromiseOrValue<BytesLike>],
  ): string;
  encodeFunctionData(
    functionFragment: 'renounceRole',
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(
    functionFragment: 'revokeRole',
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<string>],
  ): string;
  encodeFunctionData(
    functionFragment: 'schedule',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'scheduleBatch',
    values: [
      PromiseOrValue<string>[],
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BytesLike>[],
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>,
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'supportsInterface',
    values: [PromiseOrValue<BytesLike>],
  ): string;
  encodeFunctionData(
    functionFragment: 'updateDelay',
    values: [PromiseOrValue<BigNumberish>],
  ): string;

  decodeFunctionResult(
    functionFragment: 'CANCELLOR_ROLE',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'DEFAULT_ADMIN_ROLE',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'EXECUTOR_ROLE',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'PROPOSER_ROLE',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'SUPREMECOURT_ROLE',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'TIMELOCK_ADMIN_ROLE',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(functionFragment: 'VETO_ROLE', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: '_disputed', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'callDispute',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'callDisputeResolve',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(functionFragment: 'cancel', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'execute', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'executeBatch',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'getDisputeStatus',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'getMinDelay',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'getRoleAdmin',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'getTimestamp',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(functionFragment: 'grantRole', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'hasRole', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'hashOperation',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'hashOperationBatch',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'isOperation',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'isOperationDone',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'isOperationPending',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'isOperationReady',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'renounceRole',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(functionFragment: 'revokeRole', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'schedule', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'scheduleBatch',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'supportsInterface',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'updateDelay',
    data: BytesLike,
  ): Result;

  events: {
    'CallDisputed(bytes32,address,string)': EventFragment;
    'CallDisputedResolved(bytes32,bool,bytes,address,string)': EventFragment;
    'CallExecuted(bytes32,uint256,address,uint256,bytes,address,string)': EventFragment;
    'CallScheduled(bytes32,uint256,address,uint256,bytes,bytes32,uint256,address,string)': EventFragment;
    'Cancelled(bytes32,address,string)': EventFragment;
    'MinDelayChange(uint256,uint256)': EventFragment;
    'RoleAdminChanged(bytes32,bytes32,bytes32)': EventFragment;
    'RoleGranted(bytes32,address,address)': EventFragment;
    'RoleRevoked(bytes32,address,address)': EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: 'CallDisputed'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'CallDisputedResolved'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'CallExecuted'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'CallScheduled'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Cancelled'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'MinDelayChange'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'RoleAdminChanged'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'RoleGranted'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'RoleRevoked'): EventFragment;
}

export interface CallDisputedEventObject {
  id: string;
  sender: string;
  status: string;
}
export type CallDisputedEvent = TypedEvent<
  [string, string, string],
  CallDisputedEventObject
>;

export type CallDisputedEventFilter = TypedEventFilter<CallDisputedEvent>;

export interface CallDisputedResolvedEventObject {
  id: string;
  ruling: boolean;
  data: string;
  sender: string;
  status: string;
}
export type CallDisputedResolvedEvent = TypedEvent<
  [string, boolean, string, string, string],
  CallDisputedResolvedEventObject
>;

export type CallDisputedResolvedEventFilter =
  TypedEventFilter<CallDisputedResolvedEvent>;

export interface CallExecutedEventObject {
  id: string;
  index: BigNumber;
  target: string;
  value: BigNumber;
  data: string;
  sender: string;
  status: string;
}
export type CallExecutedEvent = TypedEvent<
  [string, BigNumber, string, BigNumber, string, string, string],
  CallExecutedEventObject
>;

export type CallExecutedEventFilter = TypedEventFilter<CallExecutedEvent>;

export interface CallScheduledEventObject {
  id: string;
  index: BigNumber;
  target: string;
  value: BigNumber;
  data: string;
  predecessor: string;
  readyTime: BigNumber;
  sender: string;
  status: string;
}
export type CallScheduledEvent = TypedEvent<
  [
    string,
    BigNumber,
    string,
    BigNumber,
    string,
    string,
    BigNumber,
    string,
    string,
  ],
  CallScheduledEventObject
>;

export type CallScheduledEventFilter = TypedEventFilter<CallScheduledEvent>;

export interface CancelledEventObject {
  id: string;
  sender: string;
  status: string;
}
export type CancelledEvent = TypedEvent<
  [string, string, string],
  CancelledEventObject
>;

export type CancelledEventFilter = TypedEventFilter<CancelledEvent>;

export interface MinDelayChangeEventObject {
  oldDuration: BigNumber;
  newDuration: BigNumber;
}
export type MinDelayChangeEvent = TypedEvent<
  [BigNumber, BigNumber],
  MinDelayChangeEventObject
>;

export type MinDelayChangeEventFilter = TypedEventFilter<MinDelayChangeEvent>;

export interface RoleAdminChangedEventObject {
  role: string;
  previousAdminRole: string;
  newAdminRole: string;
}
export type RoleAdminChangedEvent = TypedEvent<
  [string, string, string],
  RoleAdminChangedEventObject
>;

export type RoleAdminChangedEventFilter =
  TypedEventFilter<RoleAdminChangedEvent>;

export interface RoleGrantedEventObject {
  role: string;
  account: string;
  sender: string;
}
export type RoleGrantedEvent = TypedEvent<
  [string, string, string],
  RoleGrantedEventObject
>;

export type RoleGrantedEventFilter = TypedEventFilter<RoleGrantedEvent>;

export interface RoleRevokedEventObject {
  role: string;
  account: string;
  sender: string;
}
export type RoleRevokedEvent = TypedEvent<
  [string, string, string],
  RoleRevokedEventObject
>;

export type RoleRevokedEventFilter = TypedEventFilter<RoleRevokedEvent>;

export interface GovernanceTimelock extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: GovernanceTimelockInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined,
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>,
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>,
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    CANCELLOR_ROLE(overrides?: CallOverrides): Promise<[string]>;

    DEFAULT_ADMIN_ROLE(overrides?: CallOverrides): Promise<[string]>;

    EXECUTOR_ROLE(overrides?: CallOverrides): Promise<[string]>;

    PROPOSER_ROLE(overrides?: CallOverrides): Promise<[string]>;

    SUPREMECOURT_ROLE(overrides?: CallOverrides): Promise<[string]>;

    TIMELOCK_ADMIN_ROLE(overrides?: CallOverrides): Promise<[string]>;

    VETO_ROLE(overrides?: CallOverrides): Promise<[string]>;

    _disputed(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<[number]>;

    callDispute(
      id: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    callDisputeResolve(
      id: PromiseOrValue<BytesLike>,
      ruling: PromiseOrValue<boolean>,
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    cancel(
      id: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    execute(
      target: PromiseOrValue<string>,
      value: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      predecessor: PromiseOrValue<BytesLike>,
      salt: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    executeBatch(
      targets: PromiseOrValue<string>[],
      values: PromiseOrValue<BigNumberish>[],
      datas: PromiseOrValue<BytesLike>[],
      predecessor: PromiseOrValue<BytesLike>,
      salt: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    getDisputeStatus(
      id: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<[number] & { disputed: number }>;

    getMinDelay(
      overrides?: CallOverrides,
    ): Promise<[BigNumber] & { duration: BigNumber }>;

    getRoleAdmin(
      role: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<[string]>;

    getTimestamp(
      id: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<[BigNumber] & { timestamp: BigNumber }>;

    grantRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    hasRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<[boolean]>;

    hashOperation(
      target: PromiseOrValue<string>,
      value: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      predecessor: PromiseOrValue<BytesLike>,
      salt: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<[string] & { hash: string }>;

    hashOperationBatch(
      targets: PromiseOrValue<string>[],
      values: PromiseOrValue<BigNumberish>[],
      datas: PromiseOrValue<BytesLike>[],
      predecessor: PromiseOrValue<BytesLike>,
      salt: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<[string] & { hash: string }>;

    isOperation(
      id: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<[boolean] & { pending: boolean }>;

    isOperationDone(
      id: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<[boolean] & { done: boolean }>;

    isOperationPending(
      id: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<[boolean] & { pending: boolean }>;

    isOperationReady(
      id: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<[boolean] & { ready: boolean }>;

    renounceRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    revokeRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    schedule(
      target: PromiseOrValue<string>,
      value: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      predecessor: PromiseOrValue<BytesLike>,
      salt: PromiseOrValue<BytesLike>,
      delay: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    scheduleBatch(
      targets: PromiseOrValue<string>[],
      values: PromiseOrValue<BigNumberish>[],
      datas: PromiseOrValue<BytesLike>[],
      predecessor: PromiseOrValue<BytesLike>,
      salt: PromiseOrValue<BytesLike>,
      delay: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;

    supportsInterface(
      interfaceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<[boolean]>;

    updateDelay(
      newDelay: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<ContractTransaction>;
  };

  CANCELLOR_ROLE(overrides?: CallOverrides): Promise<string>;

  DEFAULT_ADMIN_ROLE(overrides?: CallOverrides): Promise<string>;

  EXECUTOR_ROLE(overrides?: CallOverrides): Promise<string>;

  PROPOSER_ROLE(overrides?: CallOverrides): Promise<string>;

  SUPREMECOURT_ROLE(overrides?: CallOverrides): Promise<string>;

  TIMELOCK_ADMIN_ROLE(overrides?: CallOverrides): Promise<string>;

  VETO_ROLE(overrides?: CallOverrides): Promise<string>;

  _disputed(
    arg0: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides,
  ): Promise<number>;

  callDispute(
    id: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  callDisputeResolve(
    id: PromiseOrValue<BytesLike>,
    ruling: PromiseOrValue<boolean>,
    data: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  cancel(
    id: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  execute(
    target: PromiseOrValue<string>,
    value: PromiseOrValue<BigNumberish>,
    data: PromiseOrValue<BytesLike>,
    predecessor: PromiseOrValue<BytesLike>,
    salt: PromiseOrValue<BytesLike>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  executeBatch(
    targets: PromiseOrValue<string>[],
    values: PromiseOrValue<BigNumberish>[],
    datas: PromiseOrValue<BytesLike>[],
    predecessor: PromiseOrValue<BytesLike>,
    salt: PromiseOrValue<BytesLike>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  getDisputeStatus(
    id: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides,
  ): Promise<number>;

  getMinDelay(overrides?: CallOverrides): Promise<BigNumber>;

  getRoleAdmin(
    role: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides,
  ): Promise<string>;

  getTimestamp(
    id: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  grantRole(
    role: PromiseOrValue<BytesLike>,
    account: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  hasRole(
    role: PromiseOrValue<BytesLike>,
    account: PromiseOrValue<string>,
    overrides?: CallOverrides,
  ): Promise<boolean>;

  hashOperation(
    target: PromiseOrValue<string>,
    value: PromiseOrValue<BigNumberish>,
    data: PromiseOrValue<BytesLike>,
    predecessor: PromiseOrValue<BytesLike>,
    salt: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides,
  ): Promise<string>;

  hashOperationBatch(
    targets: PromiseOrValue<string>[],
    values: PromiseOrValue<BigNumberish>[],
    datas: PromiseOrValue<BytesLike>[],
    predecessor: PromiseOrValue<BytesLike>,
    salt: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides,
  ): Promise<string>;

  isOperation(
    id: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides,
  ): Promise<boolean>;

  isOperationDone(
    id: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides,
  ): Promise<boolean>;

  isOperationPending(
    id: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides,
  ): Promise<boolean>;

  isOperationReady(
    id: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides,
  ): Promise<boolean>;

  renounceRole(
    role: PromiseOrValue<BytesLike>,
    account: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  revokeRole(
    role: PromiseOrValue<BytesLike>,
    account: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  schedule(
    target: PromiseOrValue<string>,
    value: PromiseOrValue<BigNumberish>,
    data: PromiseOrValue<BytesLike>,
    predecessor: PromiseOrValue<BytesLike>,
    salt: PromiseOrValue<BytesLike>,
    delay: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  scheduleBatch(
    targets: PromiseOrValue<string>[],
    values: PromiseOrValue<BigNumberish>[],
    datas: PromiseOrValue<BytesLike>[],
    predecessor: PromiseOrValue<BytesLike>,
    salt: PromiseOrValue<BytesLike>,
    delay: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  supportsInterface(
    interfaceId: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides,
  ): Promise<boolean>;

  updateDelay(
    newDelay: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> },
  ): Promise<ContractTransaction>;

  callStatic: {
    CANCELLOR_ROLE(overrides?: CallOverrides): Promise<string>;

    DEFAULT_ADMIN_ROLE(overrides?: CallOverrides): Promise<string>;

    EXECUTOR_ROLE(overrides?: CallOverrides): Promise<string>;

    PROPOSER_ROLE(overrides?: CallOverrides): Promise<string>;

    SUPREMECOURT_ROLE(overrides?: CallOverrides): Promise<string>;

    TIMELOCK_ADMIN_ROLE(overrides?: CallOverrides): Promise<string>;

    VETO_ROLE(overrides?: CallOverrides): Promise<string>;

    _disputed(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<number>;

    callDispute(
      id: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<void>;

    callDisputeResolve(
      id: PromiseOrValue<BytesLike>,
      ruling: PromiseOrValue<boolean>,
      data: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<void>;

    cancel(
      id: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<void>;

    execute(
      target: PromiseOrValue<string>,
      value: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      predecessor: PromiseOrValue<BytesLike>,
      salt: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<void>;

    executeBatch(
      targets: PromiseOrValue<string>[],
      values: PromiseOrValue<BigNumberish>[],
      datas: PromiseOrValue<BytesLike>[],
      predecessor: PromiseOrValue<BytesLike>,
      salt: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<void>;

    getDisputeStatus(
      id: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<number>;

    getMinDelay(overrides?: CallOverrides): Promise<BigNumber>;

    getRoleAdmin(
      role: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<string>;

    getTimestamp(
      id: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    grantRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;

    hasRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<boolean>;

    hashOperation(
      target: PromiseOrValue<string>,
      value: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      predecessor: PromiseOrValue<BytesLike>,
      salt: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<string>;

    hashOperationBatch(
      targets: PromiseOrValue<string>[],
      values: PromiseOrValue<BigNumberish>[],
      datas: PromiseOrValue<BytesLike>[],
      predecessor: PromiseOrValue<BytesLike>,
      salt: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<string>;

    isOperation(
      id: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<boolean>;

    isOperationDone(
      id: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<boolean>;

    isOperationPending(
      id: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<boolean>;

    isOperationReady(
      id: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<boolean>;

    renounceRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;

    revokeRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<void>;

    schedule(
      target: PromiseOrValue<string>,
      value: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      predecessor: PromiseOrValue<BytesLike>,
      salt: PromiseOrValue<BytesLike>,
      delay: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    scheduleBatch(
      targets: PromiseOrValue<string>[],
      values: PromiseOrValue<BigNumberish>[],
      datas: PromiseOrValue<BytesLike>[],
      predecessor: PromiseOrValue<BytesLike>,
      salt: PromiseOrValue<BytesLike>,
      delay: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;

    supportsInterface(
      interfaceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<boolean>;

    updateDelay(
      newDelay: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides,
    ): Promise<void>;
  };

  filters: {
    'CallDisputed(bytes32,address,string)'(
      id?: PromiseOrValue<BytesLike> | null,
      sender?: null,
      status?: null,
    ): CallDisputedEventFilter;
    CallDisputed(
      id?: PromiseOrValue<BytesLike> | null,
      sender?: null,
      status?: null,
    ): CallDisputedEventFilter;

    'CallDisputedResolved(bytes32,bool,bytes,address,string)'(
      id?: PromiseOrValue<BytesLike> | null,
      ruling?: null,
      data?: null,
      sender?: null,
      status?: null,
    ): CallDisputedResolvedEventFilter;
    CallDisputedResolved(
      id?: PromiseOrValue<BytesLike> | null,
      ruling?: null,
      data?: null,
      sender?: null,
      status?: null,
    ): CallDisputedResolvedEventFilter;

    'CallExecuted(bytes32,uint256,address,uint256,bytes,address,string)'(
      id?: PromiseOrValue<BytesLike> | null,
      index?: PromiseOrValue<BigNumberish> | null,
      target?: null,
      value?: null,
      data?: null,
      sender?: null,
      status?: null,
    ): CallExecutedEventFilter;
    CallExecuted(
      id?: PromiseOrValue<BytesLike> | null,
      index?: PromiseOrValue<BigNumberish> | null,
      target?: null,
      value?: null,
      data?: null,
      sender?: null,
      status?: null,
    ): CallExecutedEventFilter;

    'CallScheduled(bytes32,uint256,address,uint256,bytes,bytes32,uint256,address,string)'(
      id?: PromiseOrValue<BytesLike> | null,
      index?: PromiseOrValue<BigNumberish> | null,
      target?: null,
      value?: null,
      data?: null,
      predecessor?: null,
      readyTime?: null,
      sender?: null,
      status?: null,
    ): CallScheduledEventFilter;
    CallScheduled(
      id?: PromiseOrValue<BytesLike> | null,
      index?: PromiseOrValue<BigNumberish> | null,
      target?: null,
      value?: null,
      data?: null,
      predecessor?: null,
      readyTime?: null,
      sender?: null,
      status?: null,
    ): CallScheduledEventFilter;

    'Cancelled(bytes32,address,string)'(
      id?: PromiseOrValue<BytesLike> | null,
      sender?: null,
      status?: null,
    ): CancelledEventFilter;
    Cancelled(
      id?: PromiseOrValue<BytesLike> | null,
      sender?: null,
      status?: null,
    ): CancelledEventFilter;

    'MinDelayChange(uint256,uint256)'(
      oldDuration?: null,
      newDuration?: null,
    ): MinDelayChangeEventFilter;
    MinDelayChange(
      oldDuration?: null,
      newDuration?: null,
    ): MinDelayChangeEventFilter;

    'RoleAdminChanged(bytes32,bytes32,bytes32)'(
      role?: PromiseOrValue<BytesLike> | null,
      previousAdminRole?: PromiseOrValue<BytesLike> | null,
      newAdminRole?: PromiseOrValue<BytesLike> | null,
    ): RoleAdminChangedEventFilter;
    RoleAdminChanged(
      role?: PromiseOrValue<BytesLike> | null,
      previousAdminRole?: PromiseOrValue<BytesLike> | null,
      newAdminRole?: PromiseOrValue<BytesLike> | null,
    ): RoleAdminChangedEventFilter;

    'RoleGranted(bytes32,address,address)'(
      role?: PromiseOrValue<BytesLike> | null,
      account?: PromiseOrValue<string> | null,
      sender?: PromiseOrValue<string> | null,
    ): RoleGrantedEventFilter;
    RoleGranted(
      role?: PromiseOrValue<BytesLike> | null,
      account?: PromiseOrValue<string> | null,
      sender?: PromiseOrValue<string> | null,
    ): RoleGrantedEventFilter;

    'RoleRevoked(bytes32,address,address)'(
      role?: PromiseOrValue<BytesLike> | null,
      account?: PromiseOrValue<string> | null,
      sender?: PromiseOrValue<string> | null,
    ): RoleRevokedEventFilter;
    RoleRevoked(
      role?: PromiseOrValue<BytesLike> | null,
      account?: PromiseOrValue<string> | null,
      sender?: PromiseOrValue<string> | null,
    ): RoleRevokedEventFilter;
  };

  estimateGas: {
    CANCELLOR_ROLE(overrides?: CallOverrides): Promise<BigNumber>;

    DEFAULT_ADMIN_ROLE(overrides?: CallOverrides): Promise<BigNumber>;

    EXECUTOR_ROLE(overrides?: CallOverrides): Promise<BigNumber>;

    PROPOSER_ROLE(overrides?: CallOverrides): Promise<BigNumber>;

    SUPREMECOURT_ROLE(overrides?: CallOverrides): Promise<BigNumber>;

    TIMELOCK_ADMIN_ROLE(overrides?: CallOverrides): Promise<BigNumber>;

    VETO_ROLE(overrides?: CallOverrides): Promise<BigNumber>;

    _disputed(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    callDispute(
      id: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    callDisputeResolve(
      id: PromiseOrValue<BytesLike>,
      ruling: PromiseOrValue<boolean>,
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    cancel(
      id: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    execute(
      target: PromiseOrValue<string>,
      value: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      predecessor: PromiseOrValue<BytesLike>,
      salt: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    executeBatch(
      targets: PromiseOrValue<string>[],
      values: PromiseOrValue<BigNumberish>[],
      datas: PromiseOrValue<BytesLike>[],
      predecessor: PromiseOrValue<BytesLike>,
      salt: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    getDisputeStatus(
      id: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getMinDelay(overrides?: CallOverrides): Promise<BigNumber>;

    getRoleAdmin(
      role: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getTimestamp(
      id: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    grantRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    hasRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    hashOperation(
      target: PromiseOrValue<string>,
      value: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      predecessor: PromiseOrValue<BytesLike>,
      salt: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    hashOperationBatch(
      targets: PromiseOrValue<string>[],
      values: PromiseOrValue<BigNumberish>[],
      datas: PromiseOrValue<BytesLike>[],
      predecessor: PromiseOrValue<BytesLike>,
      salt: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    isOperation(
      id: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    isOperationDone(
      id: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    isOperationPending(
      id: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    isOperationReady(
      id: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    renounceRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    revokeRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    schedule(
      target: PromiseOrValue<string>,
      value: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      predecessor: PromiseOrValue<BytesLike>,
      salt: PromiseOrValue<BytesLike>,
      delay: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    scheduleBatch(
      targets: PromiseOrValue<string>[],
      values: PromiseOrValue<BigNumberish>[],
      datas: PromiseOrValue<BytesLike>[],
      predecessor: PromiseOrValue<BytesLike>,
      salt: PromiseOrValue<BytesLike>,
      delay: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;

    supportsInterface(
      interfaceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    updateDelay(
      newDelay: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    CANCELLOR_ROLE(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    DEFAULT_ADMIN_ROLE(
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    EXECUTOR_ROLE(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    PROPOSER_ROLE(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    SUPREMECOURT_ROLE(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    TIMELOCK_ADMIN_ROLE(
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    VETO_ROLE(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    _disputed(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    callDispute(
      id: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    callDisputeResolve(
      id: PromiseOrValue<BytesLike>,
      ruling: PromiseOrValue<boolean>,
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    cancel(
      id: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    execute(
      target: PromiseOrValue<string>,
      value: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      predecessor: PromiseOrValue<BytesLike>,
      salt: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    executeBatch(
      targets: PromiseOrValue<string>[],
      values: PromiseOrValue<BigNumberish>[],
      datas: PromiseOrValue<BytesLike>[],
      predecessor: PromiseOrValue<BytesLike>,
      salt: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    getDisputeStatus(
      id: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getMinDelay(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getRoleAdmin(
      role: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getTimestamp(
      id: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    grantRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    hasRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    hashOperation(
      target: PromiseOrValue<string>,
      value: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      predecessor: PromiseOrValue<BytesLike>,
      salt: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    hashOperationBatch(
      targets: PromiseOrValue<string>[],
      values: PromiseOrValue<BigNumberish>[],
      datas: PromiseOrValue<BytesLike>[],
      predecessor: PromiseOrValue<BytesLike>,
      salt: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    isOperation(
      id: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    isOperationDone(
      id: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    isOperationPending(
      id: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    isOperationReady(
      id: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    renounceRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    revokeRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    schedule(
      target: PromiseOrValue<string>,
      value: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      predecessor: PromiseOrValue<BytesLike>,
      salt: PromiseOrValue<BytesLike>,
      delay: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    scheduleBatch(
      targets: PromiseOrValue<string>[],
      values: PromiseOrValue<BigNumberish>[],
      datas: PromiseOrValue<BytesLike>[],
      predecessor: PromiseOrValue<BytesLike>,
      salt: PromiseOrValue<BytesLike>,
      delay: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;

    supportsInterface(
      interfaceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    updateDelay(
      newDelay: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> },
    ): Promise<PopulatedTransaction>;
  };
}
